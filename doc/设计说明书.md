本项目设计了一个较为完整的C/C++嵌入式基础项目框架，包含业务代码，编译构建，版本发布，日志，命令行，文档，开发者测试，第三方库等因素，可以为初学者在做嵌入式相关项目时提供参考。下面分几部分介绍一下该项目的整体框架。
# 1.项目目录
HAL/  ------------------------------------------- 项目组件名称，这里只是选了一个嵌入式通用的组件
├── build/  ------------------------------------- 编译脚本
|    ├── build.sh  ------------------------------ 项目的编译入口
|    ├── clean.sh  ------------------------------ 清理构建残留
|    └── help.sh   ------------------------------ 帮助信息，一般脚本需要传入特定参数，需要该文件做指导
├── cmake/  ------------------------------------- cmake文件
|    ├── aarch64-linux-gnu-gcc.cmake  ----------- 交叉编译工具链，下同
|    └── arm-linux-gnueabihf.cmake
├── code/  -------------------------------------- 业务代码在此处
|    ├── include/  ------------------------------ 对外发布的头文件统一放到include/中
|    ├── api/  ---------------------------------- 业务代码，如组件北向接口等关键业务
|    └── otherservice/  ------------------------- 业务代码，可根据实际业务开拓对应目录
├── command/  ----------------------------------- 命令行系统，方便在项目开发时DEBUG。版本发布时，除对客户承诺的必要命令，其它应裁剪。禁止预留后门
├── doc/  --------------------------------------- 项目文档和设计文档在此处，使用doxygen管理
|    ├── Doxyfile  ------------------------------ doxygen工具的配置文件，可以根据项目灵活定制
|    ├── genfile.sh  ---------------------------- 项目文档生成脚本，当业务代码提交后，可执行该脚本刷新文档
|    └── xxx.md  -------------------------------- 各类设计文档等
├── infra/  ------------------------------------- 基础设施，C代码库函数较少，部分容器需自己实现，也可根据项目定制
|    ├── stack/  -------------------------------- 栈
|    └── ...  ----------------------------------- 其他基础设施
├── log/  --------------------------------------- 日志系统
├── output/  ------------------------------------ 版本发布在此处，日志文件也可以放在这里
├── test/  -------------------------------------- 开发者测试，白盒/黑盒测试都在这里实现
|    ├── build/  -------------------------------- 仿真工程编译入口
|    ├── common/  ------------------------------- 仿真工程模拟本组件上游拉起组件初始化和配置的相关代码在此处
|    └── testcase/  ----------------------------- 具体测试用例在这里实现
├── third_party/  ------------------------------- 项目仿真工程所依赖的第三方库或下游组件
|    ├── googletest  ---------------------------- 谷歌开源测试框架，开发者测试依赖此框架
|    └── ...  ----------------------------------- 其余第三方依赖
└── CMakeLists.txt  ----------------------------- 项目顶层CMakeLists.txt

这里要说明一下，以上目录并不是绝对的，比如command/和log/等目录可以放到code里面，实际开发之前要按照项目要求对目录做评审。

# 2.开发流程
一个大型项目的工作量是巨大的，为了能够在规定时间内保质保量交付，部门的各个角色需要密切配合。
## 2.1 需求对齐
在项目开始之初，需要部门的PM（项目经理Project Manager）统计部门的人力管道，然后由DE设计工程师统一去跟上下游的其他DE讨论整个项目的业务归属和工作量分配，这个流程会涉及到需求裁剪，因为一般来说人力管道是远小于实际需求的，当需求工作量超过部门人力管道1.5倍时可能部门就吃不下了，所以会协商把一些不紧急不重要的需求放到后续的版本做，或者干脆不做。当业务归属敲定后，基本上本部门本版本要做的事就定下了。
## 2.2 需求分解
接下来就是需求的分解，首先是大类的划分，如“实现业务A”，“实现SRV6”等等这种，分解完之后，再由本部门各个小组的DE去把需求再次细化，这次细化需要足够明确，标准就是开发人员可以直接落地。在项目管理系统上，一个项目分解完之后就类似于下面的结构：
样机A项目/
├── FR:实现组播协议/
|    ├── AR:multicast.drive.创建组播组
|    ├── AR:multicast.drive.组播叶子管理
|    ├── AR:multicast.microcode.创建组播组
|    ├── AR:multicast.microcode.组播叶子管理
|    ├── AR:multicast.microcode.组播报文复制
├── FR:实现SRV6/
|    ├── AR:srv6.drive.xxx
|    ├── AR:srv6.drive.xxx
├── FR:实现ROUTE/
|    ├── AR:rout.drive.xxx
|    ├── AR:rout.drive.xxx
上面只是举个例子，实际上以项目需求为准。需求分解完成之后，部门里每个小组的工作量也定下来了，这时就需要项目经理和各个组的leader按照人力去排大版本和ST版本，一般的节奏是每个月一个大版本，每周大概一到两个ST版本，其中大版本是交付产品测试，在实际组网环境中做业务配置，主备倒换，满规格等测试，ST版本是交付部门测试团队。每个大版本要验收哪些需求，每个ST版本要交哪几个需求需要在项目开始之初就规划好，相当于每个AR都有deadline和责任人。当需求被分解为一个个AR时，就可以交给开发人员去设计开发了。
一般项目上会要求每个需求都要先做需求详细设计，初级开发人员不具备这样的能力，因此一般由团队骨干先去做需求详细设计，撰写详设文档，然后交给其他人员去做开发，一些比较大的复杂的特性会由团队骨干做设计和开发。

## 2.3 设计文档
设计文档一般有固定章节，这个看部门对文档的管理。设计文档一般包含需求背景，需求分析，实现方案，接口，测试方案等内容，在撰写之前，需要和其他业务组做方案对齐，讨论是否有遗漏或者需要几个团队配合的地方，尤其是需要团队间配合的地方要确认清楚。设计文档完成之后，需要召集专家做评审串讲，包括测试团队和北向组件，通过之后方可开发，测试团队可以根据串讲内容做测试开发，北向组件依赖我们组件的接口，文档中明确接口后，不会阻塞对方的开发进度。

## 2.4 代码开发
开发人员要严格按照设计文档的方案进行开发，提交代码时，需要关联对应的AR，方便项目完结后做回溯，一个是看工作量预估是否准确，这个就是对比预估代码量和实际开发代码量，另一个是有利于项目管理。
开发且自测完成后，开发的代码就可以跟随每周的ST版本发布给测试团队，如果测试团队没测出问题，就算内部交付闭环。如果测出问题，测试就会提问题单给开发者，开发者需要在下个ST版本之前解决问题并发一个临时版本给测试来验证问题是否解决，直到问题解决才算交付闭环。ST版本的版本号一般是从某一个数字开始，每发一次就加1。

# 3.编译构建
本项目采用cmake作为构建工具，这也是当前比较主流的构建工具，它的优点是简单易懂，结构清晰，容易上手。与此同时，项目采用模块化的构建框架，要求每个逻辑子目录都要独立构建library，且头文件依赖不能有飞线，如果某模块依赖其他子模块，则必须通过link该子模块的方式来解决依赖。

## 3.1 交付件构建
一般来说，大型/小型嵌入式设备的CPU架构都和代码编译平台（本机）不同，如开发人员的执行机一般是x86架构，而嵌入式设备大多是arm架构，所以针对不同的CPU，需要指定交叉编译工具链。在整个项目中，所有组件的编译工具链必须统一，否则在最终链接时可能会出问题。我们在开发之前，首先就是要找组件发布对象确认编译工具链。
本项目在cmake目录中
交叉编译工具链可以在执行cmake指令时指定，如下
`cmake .. -DCMAKE_TOOLCHAIN_FILE=xxx`
所以，如果项目上新增交叉编译工具，需要在cmake/中新增一个toolchain_name.cmake，其中需要指定目标系统名称，处理器和交叉编译工具，以及一些其他配置，具体请参考已有的两个xx.cmake。
toolchain_name.cmake实现之后，我们需要在build/build.sh中添加对应的分支，保证工具链生效。

## 3.2 仿真构建
上板环境中问题定位比较困难，原因是日志记录不会很详细，另外调试工具也较为匮乏，所以一般出现问题要优先在仿真环境中复现，找到必现条件之后再使用GDB等工具单步跟即可。仿真构建是在发布件的基础上增加了main函数作为入口，模拟上层调用拉起组件。仿真构建入口在test/build/目录中

# 4.仿真工程
在业务开发时，如果实现完代码之后只验证编译，那么在后续的ST（系统测试System Test）中可能会频繁测出问题，这不仅会导致在跟测试团队的拉扯中消耗时间，也会丢失别人对自身代码质量的信任，所以开发者测试是程序员必不可少的一个环节，甚至有种说法是自测所需要花费的时间要远大于代码开发的时间，我认为这是完全合理的。
为了做好DT（开发者测试Developer Test），必须要有仿真工程，因为作为一个组件，只是对外提供API，不依靠仿真工程的话就只能做一些白盒测试，端到端测试只能依赖仿真工程。在仿真工程中，我们可以随意构造初始化和API入参，拉起组件，再通过命令行或者用例做配置下发和查询，这种仿真测试是完全按照组件使用者的视角来做测试，可以保证拦截大部分问题。

# 5.日志
日志系统一般是整个项目组共用，通过某些标识来区分各个组件，我们作为某一个组件一般只需要在初始化时根据上层提供的注册接口去注册即可。这里实现一个简易的日志系统仅作为参考。

# 6.设计文档
