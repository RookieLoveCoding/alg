日志系统对于任何项目来说都至关重要，比如查看各个模块的初始化进度，业务配置过程，程序返错细节等等，一个合适的日志系统往往能够在问题定位时发挥重要作用，依赖日志系统可以快速定位到某个文件的某一行返错，并记录现场关键信息。
# 1.日志分级
通常来说我们不希望看到一个大杂烩的乱七八糟的日志文件，所以如何对日志进行合理分级分类是一个关键的问题，下面列举几个维度：
（1）根据业务组来区分
对于大型嵌入式系统的项目组来说，软件也是有分层的，如业务层，驱动层，硬件适配层等等，一些较为复杂的子模块可能还会被单独成立业务组来开发和维护，体现在部门里面就是有多个PL组。从责任田划分的角度来说，每个PL组只对自己负责的部分感兴趣，所以对于各个PL组负责的业务，每个PL组分配一个单独的日志文件是合理的。
（2）根据严重程度来区分
日志中有一些是执行进度提示，如在初始化某个阶段，开发人员可能会在该阶段的开始和结束分别记录一条日志。还有一些是返错记录，在函数的参数校验或其他校验环节不符合预期，就会返回ERROR。另外还可能有一些数据，校验不通过可能会导致数据安全或者系统崩溃的情况，返回ERROR已经不合适了，需要立刻退出进程。对于开发者来说，这些日志属于不同严重程度，需要做区分以便于筛选。

本项目中的日志系统，要按照组件和严重程度来对日志进行分类分级，具体如下：
项目驱动软件包含三个子组件，分别是FOS,NSE,HAL，所以要针对每个组件创建单独的日志文件：fos.log, nse.log, hal.log
每个组件中根据严重程度分成五个等级，从轻到重分别是DEBUG, INFO, WARNING, ERROR, FATAL

# 2.日志配置
## 2.1 日志文件最大限制
日志文件如果不做容量限制，可能会导致日志文件超大，进而影响读写性能。所以在日志配置中需要规定日志文件最多能够包含多少个字节
## 2.2 是否屏幕输出
在做调试时，如果希望直接看到程序执行过程，直接把日志打印到屏幕上是最直观的，这样就不需要导出日志文件了。但是正常情况下不会把海量日志输出屏幕，所以日志配置中需要提供是否输出屏幕的选项
## 2.3 是否循环覆盖
当日志记录满时，如果仍然有记录需求，则可以从头开始覆盖旧的日志，因为新日志通常是比旧的日志更加有价值，日志配置中需要提供是否循环覆盖的选项
## 2.4 日志文件句柄
日志记录是一个很频繁的活动，如果每次记录日志都要打开再关闭日志文件，系统开销不能接受，所以日志文件只在初始化时打开一次，并将文件句柄存储到配置中
## 2.5 日志锁
多线程场景下对同一个文件进行操作，会导致日志混乱，所以需要日志锁来保证线程安全。在初始化时申请锁，去初始化时释放锁。

综上所述，日志配置设计如下：
```
typedef struct {
    LogModule logModule; /**< 日志所属组件 */
    LogLevel logLevel; /**< 开放的日志等级 */
    char logFileName[256]; /**< 日志文件名 */
    char buffer[BUFFER_SIZE]; /**< 缓冲区 */
    FILE *file; /**< 日志文件句柄 */
    uint32_t maxByteSize; /**< 日志文件最大字节数 */
    bool consoleOutput; /**< 是否输出到屏幕 */
    bool rotate; /**< 当日志文件满时是否循环覆盖 */
    LogSafeMutex mutex; /**< 日志锁 */
} LogConfig;
```

# 3.关键接口
日志系统需要实现如下功能：初始化，去初始化，配置下发，所以关键接口设计如下：
```
uint32_t logInit(LogLevel logLevel, uint32_t maxByteSize, bool rotate);
void logDestroy();
LogConfig *logGetConfig(LogModule module);
void logSetLevel(LogModule module, LogLevel logLevel);
void logSetOutput(LogModule module, bool consoleOutput);
void logSetRotate(LogModule module, bool rotate);
```
此外，还需要封装日志宏，以保持代码简洁
```
#define HAL_LOG_DEBUG(...) logWrite(HAL, LOG_DEBUG, __FILE__, __LINE__, __VA_ARGS__);
#define HAL_LOG_INFO(...) logWrite(HAL, LOG_INFO, __FILE__, __LINE__, __VA_ARGS__);
#define HAL_LOG_WARNING(...) logWrite(HAL, LOG_WARNING, __FILE__, __LINE__, __VA_ARGS__);
#define HAL_LOG_ERROR(...) logWrite(HAL, LOG_ERROR, __FILE__, __LINE__, __VA_ARGS__);
#define HAL_LOG_FATAL(...) logWrite(HAL, LOG_FATAL, __FILE__, __LINE__, __VA_ARGS__);
```
其中logWrite(xx)函数是内部函数，不对外暴漏

# 4.日志内容
## 4.1 时间
日志需要包含时间，具体就是年月日时分秒，还有毫秒，因为在大型嵌入式设备中，每一秒都可能执行很多操作，如果不把精度设置成毫秒，就没办法看出每一个步骤具体的时间消耗。
## 4.2 日志等级
包含日志等级的主要作用是用于筛选，当我们只关心某一个等级的日志时，可以直接利用IDE的能力进行文本筛选，可以快速找到需要的日志
## 4.3 文件名&行号
文件名和行号可以帮助我们快速找到返错函数的返错行，而且如果日志记录很详细，在日志文件里面会体现出一个调用链，因为错误是会自下而上传导。C语言提供了多个预定义宏，能够帮助我们快速记录文件名，行号等。
```
__FILE__:表示当前源文件的文件名，是一个绝对路径
__LINE__:表示当前源文件的行号
__func__:C99标准引入，表示当前函数名，C++中是__FUNCTION__
```
## 4.3 日志描述&关键数据
这里是日志最关键的地方。当程序的某个步骤执行失败时，需要日志系统记录到现场的关键数据，包括但不限于错误码，函数入参，局部变量等。同时最好能够描述清楚这个返错是哪个业务的哪一个步骤出了问题，方便开发人员快速定位

综上所述，日志格式设计如下：
`[xxxx-xx-xx xx:xx:xx:xx][LEVEL]xxx.c/cpp:xx desc+data`